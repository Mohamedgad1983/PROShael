import { supabase } from '../config/database.js';\n\n/**\n * Database Optimization Service\n * Handles database schema optimizations, indexes, and performance improvements\n */\nexport class DatabaseOptimizationService {\n\n  /**\n   * Create all necessary indexes for payments table\n   */\n  static async createPaymentIndexes() {\n    try {\n      const indexes = [\n        {\n          name: 'idx_payments_payer_id',\n          sql: 'CREATE INDEX IF NOT EXISTS idx_payments_payer_id ON payments(payer_id);',\n          description: 'Index on payer_id for faster member payment lookups'\n        },\n        {\n          name: 'idx_payments_status',\n          sql: 'CREATE INDEX IF NOT EXISTS idx_payments_status ON payments(status);',\n          description: 'Index on status for faster status-based queries'\n        },\n        {\n          name: 'idx_payments_category',\n          sql: 'CREATE INDEX IF NOT EXISTS idx_payments_category ON payments(category);',\n          description: 'Index on category for faster category-based queries'\n        },\n        {\n          name: 'idx_payments_created_at',\n          sql: 'CREATE INDEX IF NOT EXISTS idx_payments_created_at ON payments(created_at);',\n          description: 'Index on created_at for date range queries'\n        },\n        {\n          name: 'idx_payments_reference_number',\n          sql: 'CREATE INDEX IF NOT EXISTS idx_payments_reference_number ON payments(reference_number);',\n          description: 'Index on reference_number for quick receipt lookups'\n        },\n        {\n          name: 'idx_payments_status_created_at',\n          sql: 'CREATE INDEX IF NOT EXISTS idx_payments_status_created_at ON payments(status, created_at);',\n          description: 'Composite index for status and date filtering'\n        },\n        {\n          name: 'idx_payments_payer_status',\n          sql: 'CREATE INDEX IF NOT EXISTS idx_payments_payer_status ON payments(payer_id, status);',\n          description: 'Composite index for member-specific status queries'\n        },\n        {\n          name: 'idx_payments_category_status',\n          sql: 'CREATE INDEX IF NOT EXISTS idx_payments_category_status ON payments(category, status);',\n          description: 'Composite index for category and status analytics'\n        }\n      ];\n\n      const results = [];\n      for (const index of indexes) {\n        try {\n          const { data, error } = await supabase.rpc('execute_sql', {\n            query: index.sql\n          });\n          \n          results.push({\n            name: index.name,\n            success: !error,\n            description: index.description,\n            error: error?.message || null\n          });\n        } catch (err) {\n          results.push({\n            name: index.name,\n            success: false,\n            description: index.description,\n            error: err.message\n          });\n        }\n      }\n\n      return {\n        success: true,\n        data: results,\n        message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙÙ‡Ø§Ø±Ø³ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ ÙÙ‡Ø§Ø±Ø³ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'\n      };\n    }\n  }\n\n  /**\n   * Create database views for common queries\n   */\n  static async createAnalyticsViews() {\n    try {\n      const views = [\n        {\n          name: 'payment_analytics_view',\n          sql: `\n            CREATE OR REPLACE VIEW payment_analytics_view AS\n            SELECT \n              p.*,\n              m.full_name,\n              m.membership_number,\n              m.phone,\n              m.email,\n              EXTRACT(YEAR FROM p.created_at) as payment_year,\n              EXTRACT(MONTH FROM p.created_at) as payment_month,\n              EXTRACT(DAY FROM p.created_at) as payment_day,\n              DATE_TRUNC('month', p.created_at) as payment_month_start,\n              DATE_TRUNC('week', p.created_at) as payment_week_start,\n              CASE \n                WHEN p.status = 'paid' THEN p.amount \n                ELSE 0 \n              END as paid_amount,\n              CASE \n                WHEN p.status = 'pending' THEN p.amount \n                ELSE 0 \n              END as pending_amount\n            FROM payments p\n            LEFT JOIN members m ON p.payer_id = m.id;\n          `,\n          description: 'Comprehensive view for payment analytics with member details'\n        },\n        {\n          name: 'monthly_revenue_view',\n          sql: `\n            CREATE OR REPLACE VIEW monthly_revenue_view AS\n            SELECT \n              DATE_TRUNC('month', created_at) as month,\n              EXTRACT(YEAR FROM created_at) as year,\n              EXTRACT(MONTH FROM created_at) as month_number,\n              category,\n              COUNT(*) as payment_count,\n              SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) as total_revenue,\n              SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) as pending_revenue,\n              AVG(CASE WHEN status = 'paid' THEN amount ELSE NULL END) as avg_payment\n            FROM payments\n            GROUP BY DATE_TRUNC('month', created_at), EXTRACT(YEAR FROM created_at), \n                     EXTRACT(MONTH FROM created_at), category\n            ORDER BY month DESC;\n          `,\n          description: 'Monthly revenue breakdown by category'\n        },\n        {\n          name: 'member_payment_summary_view',\n          sql: `\n            CREATE OR REPLACE VIEW member_payment_summary_view AS\n            SELECT \n              m.id as member_id,\n              m.full_name,\n              m.membership_number,\n              m.phone,\n              COUNT(p.id) as total_payments,\n              SUM(CASE WHEN p.status = 'paid' THEN p.amount ELSE 0 END) as total_paid,\n              SUM(CASE WHEN p.status = 'pending' THEN p.amount ELSE 0 END) as total_pending,\n              MAX(CASE WHEN p.status = 'paid' THEN p.created_at ELSE NULL END) as last_payment_date,\n              AVG(CASE WHEN p.status = 'paid' THEN p.amount ELSE NULL END) as avg_payment,\n              COUNT(CASE WHEN p.category = 'subscription' AND p.status = 'paid' THEN 1 ELSE NULL END) as subscription_count\n            FROM members m\n            LEFT JOIN payments p ON m.id = p.payer_id\n            WHERE m.is_active = true\n            GROUP BY m.id, m.full_name, m.membership_number, m.phone\n            ORDER BY total_paid DESC;\n          `,\n          description: 'Member payment summary for quick analysis'\n        },\n        {\n          name: 'overdue_payments_view',\n          sql: `\n            CREATE OR REPLACE VIEW overdue_payments_view AS\n            SELECT \n              p.*,\n              m.full_name,\n              m.phone,\n              m.email,\n              DATE_PART('day', NOW() - p.created_at) as days_overdue,\n              CASE \n                WHEN DATE_PART('day', NOW() - p.created_at) BETWEEN 30 AND 59 THEN '30-60 days'\n                WHEN DATE_PART('day', NOW() - p.created_at) BETWEEN 60 AND 89 THEN '60-90 days'\n                WHEN DATE_PART('day', NOW() - p.created_at) >= 90 THEN '90+ days'\n                ELSE 'Current'\n              END as overdue_category\n            FROM payments p\n            LEFT JOIN members m ON p.payer_id = m.id\n            WHERE p.status = 'pending' \n              AND p.created_at < NOW() - INTERVAL '30 days'\n            ORDER BY p.created_at ASC;\n          `,\n          description: 'View for overdue payments with categorization'\n        }\n      ];\n\n      const results = [];\n      for (const view of views) {\n        try {\n          const { data, error } = await supabase.rpc('execute_sql', {\n            query: view.sql\n          });\n          \n          results.push({\n            name: view.name,\n            success: !error,\n            description: view.description,\n            error: error?.message || null\n          });\n        } catch (err) {\n          results.push({\n            name: view.name,\n            success: false,\n            description: view.description,\n            error: err.message\n          });\n        }\n      }\n\n      return {\n        success: true,\n        data: results,\n        message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ø±ÙˆØ¶ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª'\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ø±ÙˆØ¶ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'\n      };\n    }\n  }\n\n  /**\n   * Create audit logging triggers\n   */\n  static async createAuditLogging() {\n    try {\n      const auditSQL = `\n        -- Create audit log table\n        CREATE TABLE IF NOT EXISTS payment_audit_log (\n          id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n          payment_id UUID,\n          action VARCHAR(50) NOT NULL, -- INSERT, UPDATE, DELETE\n          old_values JSONB,\n          new_values JSONB,\n          changed_by VARCHAR(255),\n          changed_at TIMESTAMP DEFAULT NOW()\n        );\n\n        -- Create audit trigger function\n        CREATE OR REPLACE FUNCTION audit_payment_changes()\n        RETURNS TRIGGER AS $$\n        BEGIN\n          IF TG_OP = 'DELETE' THEN\n            INSERT INTO payment_audit_log (\n              payment_id, action, old_values, changed_at\n            ) VALUES (\n              OLD.id, TG_OP, row_to_json(OLD), NOW()\n            );\n            RETURN OLD;\n          ELSIF TG_OP = 'UPDATE' THEN\n            INSERT INTO payment_audit_log (\n              payment_id, action, old_values, new_values, changed_at\n            ) VALUES (\n              NEW.id, TG_OP, row_to_json(OLD), row_to_json(NEW), NOW()\n            );\n            RETURN NEW;\n          ELSIF TG_OP = 'INSERT' THEN\n            INSERT INTO payment_audit_log (\n              payment_id, action, new_values, changed_at\n            ) VALUES (\n              NEW.id, TG_OP, row_to_json(NEW), NOW()\n            );\n            RETURN NEW;\n          END IF;\n          RETURN NULL;\n        END;\n        $$ LANGUAGE plpgsql;\n\n        -- Create audit trigger\n        DROP TRIGGER IF EXISTS payment_audit_trigger ON payments;\n        CREATE TRIGGER payment_audit_trigger\n          AFTER INSERT OR UPDATE OR DELETE ON payments\n          FOR EACH ROW EXECUTE FUNCTION audit_payment_changes();\n\n        -- Create index on audit log\n        CREATE INDEX IF NOT EXISTS idx_audit_payment_id ON payment_audit_log(payment_id);\n        CREATE INDEX IF NOT EXISTS idx_audit_changed_at ON payment_audit_log(changed_at);\n      `;\n\n      const { data, error } = await supabase.rpc('execute_sql', {\n        query: auditSQL\n      });\n\n      return {\n        success: !error,\n        data: data,\n        message: error ? error.message : 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª',\n        error: error?.message || null\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª'\n      };\n    }\n  }\n\n  /**\n   * Optimize payments table structure\n   */\n  static async optimizePaymentsTable() {\n    try {\n      const optimizations = [\n        {\n          name: 'Add missing columns',\n          sql: `\n            ALTER TABLE payments \n            ADD COLUMN IF NOT EXISTS processed_at TIMESTAMP,\n            ADD COLUMN IF NOT EXISTS due_date DATE,\n            ADD COLUMN IF NOT EXISTS receipt_generated BOOLEAN DEFAULT FALSE,\n            ADD COLUMN IF NOT EXISTS receipt_sent BOOLEAN DEFAULT FALSE,\n            ADD COLUMN IF NOT EXISTS reminder_count INTEGER DEFAULT 0,\n            ADD COLUMN IF NOT EXISTS last_reminder_sent TIMESTAMP;\n          `\n        },\n        {\n          name: 'Update constraints',\n          sql: `\n            -- Add check constraints\n            ALTER TABLE payments DROP CONSTRAINT IF EXISTS check_amount_positive;\n            ALTER TABLE payments ADD CONSTRAINT check_amount_positive \n              CHECK (amount > 0 AND amount <= 100000);\n            \n            ALTER TABLE payments DROP CONSTRAINT IF EXISTS check_valid_status;\n            ALTER TABLE payments ADD CONSTRAINT check_valid_status \n              CHECK (status IN ('pending', 'paid', 'cancelled', 'failed', 'refunded'));\n            \n            ALTER TABLE payments DROP CONSTRAINT IF EXISTS check_valid_category;\n            ALTER TABLE payments ADD CONSTRAINT check_valid_category \n              CHECK (category IN ('subscription', 'donation', 'event', 'membership', 'other'));\n          `\n        },\n        {\n          name: 'Add unique constraints',\n          sql: `\n            -- Ensure reference number is unique\n            ALTER TABLE payments DROP CONSTRAINT IF EXISTS unique_reference_number;\n            ALTER TABLE payments ADD CONSTRAINT unique_reference_number \n              UNIQUE (reference_number);\n          `\n        }\n      ];\n\n      const results = [];\n      for (const optimization of optimizations) {\n        try {\n          const { data, error } = await supabase.rpc('execute_sql', {\n            query: optimization.sql\n          });\n          \n          results.push({\n            name: optimization.name,\n            success: !error,\n            error: error?.message || null\n          });\n        } catch (err) {\n          results.push({\n            name: optimization.name,\n            success: false,\n            error: err.message\n          });\n        }\n      }\n\n      return {\n        success: true,\n        data: results,\n        message: 'ØªÙ… ØªØ­Ø³ÙŠÙ† Ù‡ÙŠÙƒÙ„ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª'\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ù‡ÙŠÙƒÙ„ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª'\n      };\n    }\n  }\n\n  /**\n   * Run full database optimization\n   */\n  static async runFullOptimization() {\n    try {\n      log.info('ğŸ”§ Starting database optimization...');\n      \n      const results = {\n        tableOptimization: null,\n        indexes: null,\n        views: null,\n        auditLogging: null\n      };\n\n      // 1. Optimize table structure\n      log.info('1. Optimizing payments table structure...');\n      results.tableOptimization = await this.optimizePaymentsTable();\n\n      // 2. Create indexes\n      log.info('2. Creating database indexes...');\n      results.indexes = await this.createPaymentIndexes();\n\n      // 3. Create views\n      log.info('3. Creating analytics views...');\n      results.views = await this.createAnalyticsViews();\n\n      // 4. Set up audit logging\n      log.info('4. Setting up audit logging...');\n      results.auditLogging = await this.createAuditLogging();\n\n      log.info('âœ… Database optimization completed!');\n\n      return {\n        success: true,\n        data: results,\n        message: 'ØªÙ… ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­'\n      };\n\n    } catch (error) {\n      log.error('âŒ Database optimization failed:', { error: error.message });\n      return {\n        success: false,\n        error: error.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'\n      };\n    }\n  }\n\n  /**\n   * Get database performance statistics\n   */\n  static async getPerformanceStats() {\n    try {\n      const stats = {\n        tableStats: null,\n        indexStats: null,\n        queryStats: null\n      };\n\n      // Get table statistics\n      const { data: tableData } = await supabase.rpc('execute_sql', {\n        query: `\n          SELECT \n            schemaname,\n            tablename,\n            n_tup_ins as inserts,\n            n_tup_upd as updates,\n            n_tup_del as deletes,\n            n_live_tup as live_tuples,\n            n_dead_tup as dead_tuples\n          FROM pg_stat_user_tables \n          WHERE tablename IN ('payments', 'members', 'subscriptions');\n        `\n      });\n      stats.tableStats = tableData;\n\n      // Get index usage statistics\n      const { data: indexData } = await supabase.rpc('execute_sql', {\n        query: `\n          SELECT \n            schemaname,\n            tablename,\n            indexname,\n            idx_scan as index_scans,\n            idx_tup_read as tuples_read,\n            idx_tup_fetch as tuples_fetched\n          FROM pg_stat_user_indexes \n          WHERE tablename IN ('payments', 'members', 'subscriptions')\n          ORDER BY idx_scan DESC;\n        `\n      });\n      stats.indexStats = indexData;\n\n      return {\n        success: true,\n        data: stats,\n        message: 'ØªÙ… Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡'\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡'\n      };\n    }\n  }\n\n  /**\n   * Clean up old audit logs\n   * @param {number} daysToKeep - Number of days to keep logs\n   */\n  static async cleanupAuditLogs(daysToKeep = 90) {\n    try {\n      const { data, error } = await supabase.rpc('execute_sql', {\n        query: `\n          DELETE FROM payment_audit_log \n          WHERE changed_at < NOW() - INTERVAL '${daysToKeep} days';\n        `\n      });\n\n      return {\n        success: !error,\n        data: data,\n        message: `ØªÙ… ØªÙ†Ø¸ÙŠÙ Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø£Ù‚Ø¯Ù… Ù…Ù† ${daysToKeep} ÙŠÙˆÙ…`,\n        error: error?.message || null\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message || 'ÙØ´Ù„ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª'\n      };\n    }\n  }\n\n  /**\n   * Analyze table and suggest optimizations\n   */\n  static async analyzeAndSuggest() {\n    try {\n      const suggestions = [];\n\n      // Check for missing indexes\n      const { data: slowQueries } = await supabase.rpc('execute_sql', {\n        query: `\n          SELECT query, calls, total_time, mean_time\n          FROM pg_stat_statements \n          WHERE query LIKE '%payments%'\n          ORDER BY total_time DESC \n          LIMIT 10;\n        `\n      });\n\n      if (slowQueries && slowQueries.length > 0) {\n        suggestions.push({\n          type: 'performance',\n          severity: 'medium',\n          message: 'ØªÙˆØ¬Ø¯ Ø§Ø³ØªØ¹Ù„Ø§Ù…Ø§Øª Ø¨Ø·ÙŠØ¦Ø© ØªØªØ¹Ù„Ù‚ Ø¨Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª',\n          action: 'ÙØ­Øµ ÙˆØ¥Ø¶Ø§ÙØ© ÙÙ‡Ø§Ø±Ø³ Ù…Ù†Ø§Ø³Ø¨Ø©'\n        });\n      }\n\n      // Check table bloat\n      const { data: bloatData } = await supabase.rpc('execute_sql', {\n        query: `\n          SELECT \n            n_dead_tup,\n            n_live_tup,\n            CASE \n              WHEN n_live_tup > 0 THEN (n_dead_tup::float / n_live_tup * 100)\n              ELSE 0 \n            END as bloat_percentage\n          FROM pg_stat_user_tables \n          WHERE tablename = 'payments';\n        `\n      });\n\n      if (bloatData && bloatData[0]?.bloat_percentage > 10) {\n        suggestions.push({\n          type: 'maintenance',\n          severity: 'low',\n          message: 'Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª ÙŠØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØµÙŠØ§Ù†Ø©',\n          action: 'ØªØ´ØºÙŠÙ„ VACUUM ANALYZE Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯ÙˆÙ„'\n        });\n      }\n\n      return {\n        success: true,\n        data: {\n          suggestions,\n          slowQueries,\n          tableHealth: bloatData\n        },\n        message: 'ØªÙ… ØªØ­Ù„ÙŠÙ„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'\n      };\n    }\n  }\n}
import { log } from '../utils/logger.js';

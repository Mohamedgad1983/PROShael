# ðŸŽ¯ TEST CATEGORIES & SPECIFIC FIX STRATEGIES

## Overview

This document provides detailed fix strategies for each category of test failure, with code examples and common patterns.

---

## ðŸ—„ï¸ CATEGORY 1: DATABASE-RELATED TEST FAILURES

### Common Issues and Solutions

#### Issue 1.1: Foreign Key Constraint Violations

**Symptom**:
```
Error: insert or update on table "subscriptions" violates foreign key constraint "subscriptions_member_id_fkey"
```

**Root Cause**: Trying to insert a record that references a non-existent member.

**Fix Strategy**:
```javascript
// âŒ WRONG - Create subscription without member
test('should create subscription', async () => {
  const subscription = await createSubscription({
    member_id: 'non-existent-uuid',
    amount: 50
  });
  // This will fail!
});

// âœ… CORRECT - Create member first
test('should create subscription', async () => {
  // Step 1: Create member
  const member = await createTestMember({
    full_name_ar: 'Ù…Ø­Ù…Ø¯ Ø§Ù„Ø´Ø¹ÙŠÙ„',
    full_name_en: 'Mohammed Alshuail',
    national_id: '1234567890'
  });
  
  // Step 2: Create subscription with valid member_id
  const subscription = await createSubscription({
    member_id: member.id,
    amount: 50
  });
  
  expect(subscription).toBeDefined();
  expect(subscription.member_id).toBe(member.id);
});
```

**Prevention Pattern**:
```javascript
// Create reusable test fixtures with proper relationships
const createTestSubscription = async (overrides = {}) => {
  // Always create member first
  const member = await createTestMember();
  const plan = await getOrCreateSubscriptionPlan();
  
  return await db.subscriptions.create({
    member_id: member.id,
    plan_id: plan.id,
    amount: 50,
    status: 'active',
    ...overrides
  });
};
```

---

#### Issue 1.2: NULL in NOT NULL Column

**Symptom**:
```
Error: null value in column "full_name_ar" violates not-null constraint
```

**Root Cause**: Missing required field in INSERT.

**Fix Strategy**:
```javascript
// âŒ WRONG - Missing required field
const member = await createMember({
  full_name_en: 'Mohammed Alshuail',
  national_id: '1234567890'
  // Missing: full_name_ar (required!)
});

// âœ… CORRECT - Include all required fields
const member = await createMember({
  full_name_ar: 'Ù…Ø­Ù…Ø¯ Ø§Ù„Ø´Ø¹ÙŠÙ„',  // âœ… Added
  full_name_en: 'Mohammed Alshuail',
  national_id: '1234567890',
  phone: '+966550000001',
  date_of_birth: '1990-01-01',
  family_branch_id: testBranch.id  // âœ… Required FK
});
```

**Prevention Pattern**:
```javascript
// Create complete fixtures with all required fields
const COMPLETE_MEMBER_FIXTURE = {
  full_name_ar: 'Ù…Ø­Ù…Ø¯ Ø¨Ù† Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ø§Ù„Ø´Ø¹ÙŠÙ„',
  full_name_en: 'Mohammed Abdullah Alshuail',
  national_id: '1234567890',
  phone: '+966550000001',
  email: 'test@alshuail.com',
  date_of_birth: '1990-01-01',
  gender: 'male',
  marital_status: 'married',
  is_active: true
};

// Use in tests with overrides
const member = await createMember({
  ...COMPLETE_MEMBER_FIXTURE,
  email: 'specific@test.com' // Override specific fields
});
```

---

#### Issue 1.3: UUID Generation Issues

**Symptom**:
```
Error: invalid input syntax for type uuid: "undefined"
```

**Root Cause**: Not generating proper UUID or passing undefined.

**Fix Strategy**:
```javascript
const { v4: uuidv4 } = require('uuid');

// âŒ WRONG - Using string or undefined
const member = {
  id: 'member-123',  // Not a valid UUID!
  name: 'Test'
};

// âœ… CORRECT - Generate proper UUID
const member = {
  id: uuidv4(),  // âœ… Generates: "123e4567-e89b-12d3-a456-426614174000"
  name: 'Test'
};

// âœ… EVEN BETTER - Let database generate
const member = await db.query(`
  INSERT INTO members (full_name_ar, full_name_en, national_id)
  VALUES ($1, $2, $3)
  RETURNING id
`, ['Ù…Ø­Ù…Ø¯', 'Mohammed', '1234567890']);
// id is auto-generated by database
```

---

#### Issue 1.4: Arabic Text Encoding Issues

**Symptom**:
```
Error: character with byte sequence 0xd9 0x85 in encoding "UTF8" has no equivalent in encoding "LATIN1"
```

**Root Cause**: Database connection not using UTF-8 encoding.

**Fix Strategy**:
```javascript
// âŒ WRONG - Connection without UTF-8
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

// âœ… CORRECT - Force UTF-8 encoding
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
  // Add this:
  options: '-c client_encoding=UTF8'
});

// Or in connection string:
// postgresql://user:pass@host:5432/db?client_encoding=UTF8
```

**Test Validation**:
```javascript
test('should handle Arabic text correctly', async () => {
  const arabicName = 'Ù…Ø­Ù…Ø¯ Ø¨Ù† Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ø§Ù„Ø´Ø¹ÙŠÙ„';
  
  const member = await createMember({
    full_name_ar: arabicName,
    full_name_en: 'Mohammed'
  });
  
  // Verify Arabic text preserved
  expect(member.full_name_ar).toBe(arabicName);
  expect(member.full_name_ar).toMatch(/[\u0600-\u06FF]/);  // Contains Arabic
});
```

---

#### Issue 1.5: Hijri Date Conversion Errors

**Symptom**:
```
Error: Invalid Hijri date format
```

**Root Cause**: Incorrect date format or conversion logic.

**Fix Strategy**:
```javascript
const moment = require('moment-hijri');

// âŒ WRONG - Incorrect format
const hijriDate = moment().format('YYYY/MM/DD');  // This is Gregorian!

// âœ… CORRECT - Use Hijri format
const hijriDate = moment().format('iYYYY/iM/iD');  // âœ… 1447/5/24

// Conversion functions
const gregorianToHijri = (gregorianDate) => {
  return moment(gregorianDate, 'YYYY-MM-DD').format('iYYYY/iM/iD');
};

const hijriToGregorian = (hijriDate) => {
  return moment(hijriDate, 'iYYYY/iM/iD').format('YYYY-MM-DD');
};

// Test validation
test('should convert dates correctly', () => {
  const gregorian = '2025-11-25';
  const hijri = gregorianToHijri(gregorian);
  
  expect(hijri).toMatch(/^\d{4}\/\d{1,2}\/\d{1,2}$/);
  
  const backToGregorian = hijriToGregorian(hijri);
  expect(backToGregorian).toBe(gregorian);
});
```

---

## ðŸ” CATEGORY 2: AUTHENTICATION & AUTHORIZATION FAILURES

### Common Issues and Solutions

#### Issue 2.1: JWT Token Generation/Validation

**Symptom**:
```
Error: jwt malformed
Error: invalid token
```

**Root Cause**: Token not generated correctly or validation failing.

**Fix Strategy**:
```javascript
const jwt = require('jsonwebtoken');

// âŒ WRONG - Missing required claims
const token = jwt.sign(
  { userId: '123' },
  process.env.JWT_SECRET
);

// âœ… CORRECT - Include all required claims
const generateToken = (userId, role) => {
  return jwt.sign(
    {
      userId: userId,
      role: role,
      iat: Math.floor(Date.now() / 1000),  // Issued at
      exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60)  // 7 days
    },
    process.env.JWT_SECRET || 'test-secret-key'
  );
};

// Token validation
const validateToken = (token) => {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'test-secret-key');
    
    // Check expiration
    if (decoded.exp < Math.floor(Date.now() / 1000)) {
      throw new Error('Token expired');
    }
    
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Test helper
const createAuthToken = (role = 'member') => {
  const userId = uuidv4();
  return {
    userId,
    token: generateToken(userId, role)
  };
};
```

**Test Pattern**:
```javascript
test('should authenticate with valid token', async () => {
  const { userId, token } = createAuthToken('admin');
  
  const response = await request(app)
    .get('/api/v1/members')
    .set('Authorization', `Bearer ${token}`)
    .expect(200);
  
  expect(response.body.data).toBeDefined();
});

test('should reject expired token', async () => {
  // Create token that expired 1 day ago
  const expiredToken = jwt.sign(
    {
      userId: uuidv4(),
      role: 'member',
      exp: Math.floor(Date.now() / 1000) - (24 * 60 * 60)  // Yesterday
    },
    process.env.JWT_SECRET
  );
  
  await request(app)
    .get('/api/v1/members')
    .set('Authorization', `Bearer ${expiredToken}`)
    .expect(401);
});
```

---

#### Issue 2.2: RBAC Permission Checks Not Enforced

**Symptom**:
```
Test expects 403 Forbidden, but got 200 OK
```

**Root Cause**: Missing permission check in middleware.

**Fix Strategy**:
```javascript
// âŒ WRONG - No permission check
app.get('/api/v1/financial-reports', authenticateToken, async (req, res) => {
  const reports = await getFinancialReports();
  res.json({ data: reports });
});

// âœ… CORRECT - Add permission middleware
const requirePermission = (permission) => {
  return (req, res, next) => {
    const userRole = req.user.role;
    
    // Super admin has all permissions
    if (userRole === 'super_admin') {
      return next();
    }
    
    // Check role-specific permissions
    const rolePermissions = {
      admin: ['view_finances', 'manage_members'],
      financial_manager: ['view_finances', 'manage_payments'],
      member: ['view_own_data']
    };
    
    const permissions = rolePermissions[userRole] || [];
    
    if (!permissions.includes(permission)) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    
    next();
  };
};

// Apply to route
app.get('/api/v1/financial-reports',
  authenticateToken,
  requirePermission('view_finances'),  // âœ… Added
  async (req, res) => {
    const reports = await getFinancialReports();
    res.json({ data: reports });
  }
);
```

**Test Pattern**:
```javascript
describe('RBAC Authorization', () => {
  test('super_admin can access all endpoints', async () => {
    const { token } = createAuthToken('super_admin');
    
    await request(app)
      .get('/api/v1/financial-reports')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);
  });
  
  test('financial_manager can access financial endpoints', async () => {
    const { token } = createAuthToken('financial_manager');
    
    await request(app)
      .get('/api/v1/financial-reports')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);
  });
  
  test('regular member cannot access financial reports', async () => {
    const { token } = createAuthToken('member');
    
    await request(app)
      .get('/api/v1/financial-reports')
      .set('Authorization', `Bearer ${token}`)
      .expect(403);
  });
});
```

---

#### Issue 2.3: Password Hashing Mismatches

**Symptom**:
```
Error: Invalid credentials (but password is correct)
```

**Root Cause**: Bcrypt rounds mismatch or comparison error.

**Fix Strategy**:
```javascript
const bcrypt = require('bcrypt');

const SALT_ROUNDS = 10;  // âš ï¸ Must be same everywhere

// âŒ WRONG - Different salt rounds
const hash1 = await bcrypt.hash('password', 10);
const hash2 = await bcrypt.hash('password', 12);  // Different!

// âœ… CORRECT - Consistent hashing
const hashPassword = async (password) => {
  return await bcrypt.hash(password, SALT_ROUNDS);
};

const comparePassword = async (password, hash) => {
  return await bcrypt.compare(password, hash);
};

// In registration
const hashedPassword = await hashPassword(userPassword);
await db.users.create({
  email: email,
  password_hash: hashedPassword  // Store hash, not plain password
});

// In login
const user = await db.users.findByEmail(email);
const isValid = await comparePassword(inputPassword, user.password_hash);

if (!isValid) {
  throw new Error('Invalid credentials');
}
```

**Test Pattern**:
```javascript
test('should hash password correctly', async () => {
  const password = 'TestPassword123!';
  const hash = await hashPassword(password);
  
  // Verify it's hashed (not plain text)
  expect(hash).not.toBe(password);
  expect(hash.length).toBeGreaterThan(50);
  
  // Verify comparison works
  const isValid = await comparePassword(password, hash);
  expect(isValid).toBe(true);
  
  // Verify wrong password fails
  const isInvalid = await comparePassword('WrongPassword', hash);
  expect(isInvalid).toBe(false);
});
```

---

## ðŸ’¼ CATEGORY 3: BUSINESS LOGIC FAILURES

### Common Issues and Solutions

#### Issue 3.1: Subscription Calculation Errors

**Symptom**:
```
Expected: 50, Received: undefined
Expected: 45, Received: 50 (discount not applied)
```

**Root Cause**: Logic error in calculation function.

**Fix Strategy**:
```javascript
// âŒ WRONG - Missing return or incorrect logic
function calculateSubscription(memberType, familySize) {
  const BASE_AMOUNT = 50;
  
  if (familySize >= 5) {
    BASE_AMOUNT * 0.9;  // Missing return!
  }
  
  // Missing return here too!
}

// âœ… CORRECT - Proper calculation with all cases
function calculateSubscription(memberType, familySize) {
  const BASE_AMOUNT = 50;
  
  // Validate inputs
  if (typeof familySize !== 'number' || familySize < 0) {
    throw new Error('Invalid family size');
  }
  
  // Apply family discount (10% for 5+ members)
  if (familySize >= 5) {
    return BASE_AMOUNT * 0.9;  // âœ… 45 SAR
  }
  
  // Apply founding member discount (20%)
  if (memberType === 'founding_member') {
    return BASE_AMOUNT * 0.8;  // âœ… 40 SAR
  }
  
  // Base amount
  return BASE_AMOUNT;  // âœ… 50 SAR
}
```

**Comprehensive Test Suite**:
```javascript
describe('Subscription Calculation', () => {
  test('base subscription is 50 SAR', () => {
    expect(calculateSubscription('regular', 1)).toBe(50);
  });
  
  test('family discount for 5+ members', () => {
    expect(calculateSubscription('regular', 5)).toBe(45);
    expect(calculateSubscription('regular', 10)).toBe(45);
  });
  
  test('no discount for less than 5 members', () => {
    expect(calculateSubscription('regular', 4)).toBe(50);
  });
  
  test('founding member discount', () => {
    expect(calculateSubscription('founding_member', 1)).toBe(40);
  });
  
  test('edge case: zero family size', () => {
    expect(calculateSubscription('regular', 0)).toBe(50);
  });
  
  test('edge case: negative family size throws error', () => {
    expect(() => calculateSubscription('regular', -1)).toThrow();
  });
  
  test('edge case: very large family', () => {
    expect(calculateSubscription('regular', 100)).toBe(45);
  });
});
```

---

#### Issue 3.2: Family Tree Relationship Validation

**Symptom**:
```
Error: Circular reference detected (but shouldn't allow)
Self-reference created (A â†’ A)
```

**Root Cause**: Missing validation logic.

**Fix Strategy**:
```javascript
// âŒ WRONG - No validation
async function createRelationship(memberFrom, memberTo, type) {
  await db.family_relationships.create({
    member_from: memberFrom,
    member_to: memberTo,
    relationship_type: type
  });
}

// âœ… CORRECT - Comprehensive validation
async function createRelationship(memberFrom, memberTo, type) {
  // 1. Validate both members exist
  const [from, to] = await Promise.all([
    db.members.findById(memberFrom),
    db.members.findById(memberTo)
  ]);
  
  if (!from || !to) {
    throw new Error('Member not found');
  }
  
  // 2. Prevent self-reference
  if (memberFrom === memberTo) {
    throw new Error('Cannot create self-referential relationship');
  }
  
  // 3. Validate relationship type
  const VALID_TYPES = [
    'father', 'mother', 'son', 'daughter',
    'brother', 'sister', 'grandfather', 'grandmother',
    'uncle', 'aunt', 'cousin', 'nephew', 'niece'
  ];
  
  if (!VALID_TYPES.includes(type)) {
    throw new Error(`Invalid relationship type: ${type}`);
  }
  
  // 4. Check for circular reference
  const isCircular = await checkCircularReference(memberFrom, memberTo);
  if (isCircular) {
    throw new Error('Circular relationship detected');
  }
  
  // 5. Create relationship
  return await db.family_relationships.create({
    member_from: memberFrom,
    member_to: memberTo,
    relationship_type: type
  });
}

// Helper function
async function checkCircularReference(from, to, visited = new Set()) {
  if (visited.has(from)) return true;
  visited.add(from);
  
  const relationships = await db.family_relationships.findWhere({
    member_from: to
  });
  
  for (const rel of relationships) {
    if (rel.member_to === from) return true;
    if (await checkCircularReference(from, rel.member_to, visited)) {
      return true;
    }
  }
  
  return false;
}
```

**Test Suite**:
```javascript
describe('Family Relationships', () => {
  let member1, member2, member3;
  
  beforeEach(async () => {
    member1 = await createTestMember({ full_name_en: 'Member 1' });
    member2 = await createTestMember({ full_name_en: 'Member 2' });
    member3 = await createTestMember({ full_name_en: 'Member 3' });
  });
  
  test('should create valid relationship', async () => {
    const rel = await createRelationship(member1.id, member2.id, 'father');
    expect(rel).toBeDefined();
    expect(rel.relationship_type).toBe('father');
  });
  
  test('should prevent self-reference', async () => {
    await expect(
      createRelationship(member1.id, member1.id, 'brother')
    ).rejects.toThrow('self-referential');
  });
  
  test('should prevent circular reference', async () => {
    // Create: A â†’ B
    await createRelationship(member1.id, member2.id, 'father');
    
    // Try to create: B â†’ A (circular)
    await expect(
      createRelationship(member2.id, member1.id, 'son')
    ).rejects.toThrow('Circular');
  });
  
  test('should reject invalid relationship type', async () => {
    await expect(
      createRelationship(member1.id, member2.id, 'invalid_type')
    ).rejects.toThrow('Invalid relationship type');
  });
});
```

---

#### Issue 3.3: Diya Case Calculation

**Symptom**:
```
Expected diya amount: 100000, Received: undefined
```

**Root Cause**: Missing calculation logic or incorrect formula.

**Fix Strategy**:
```javascript
// Diya amounts based on Islamic law
const DIYA_BASE_AMOUNT = 100000;  // SAR

const DIYA_MULTIPLIERS = {
  'accidental_death': 1.0,      // Full diya
  'intentional_injury': 0.5,    // 50%
  'accidental_injury': 0.3,     // 30%
  'severe_injury': 0.7,         // 70%
  'minor_injury': 0.1           // 10%
};

// âŒ WRONG - No validation or calculation
function calculateDiyaAmount(caseType) {
  return DIYA_BASE_AMOUNT;  // Always same amount!
}

// âœ… CORRECT - Proper calculation
function calculateDiyaAmount(caseType, severity = 'normal') {
  // Validate case type
  if (!DIYA_MULTIPLIERS.hasOwnProperty(caseType)) {
    throw new Error(`Invalid case type: ${caseType}`);
  }
  
  // Base calculation
  const multiplier = DIYA_MULTIPLIERS[caseType];
  let amount = DIYA_BASE_AMOUNT * multiplier;
  
  // Adjust for severity if applicable
  if (caseType.includes('injury') && severity === 'severe') {
    amount *= 1.5;  // Increase by 50%
  }
  
  return Math.round(amount);  // Round to whole SAR
}
```

**Test Suite**:
```javascript
describe('Diya Calculations', () => {
  test('accidental death - full diya', () => {
    expect(calculateDiyaAmount('accidental_death')).toBe(100000);
  });
  
  test('intentional injury - 50%', () => {
    expect(calculateDiyaAmount('intentional_injury')).toBe(50000);
  });
  
  test('accidental injury - 30%', () => {
    expect(calculateDiyaAmount('accidental_injury')).toBe(30000);
  });
  
  test('severe injury adjustment', () => {
    const base = calculateDiyaAmount('accidental_injury');
    const severe = calculateDiyaAmount('accidental_injury', 'severe');
    expect(severe).toBe(base * 1.5);
  });
  
  test('invalid case type throws error', () => {
    expect(() => calculateDiyaAmount('invalid_type')).toThrow();
  });
});
```

---

## ðŸŒ CATEGORY 4: API ENDPOINT FAILURES

### Common Issues and Solutions

#### Issue 4.1: Route Not Found (404)

**Symptom**:
```
Error: Cannot GET /api/v1/members
404 Not Found
```

**Root Cause**: Route not registered or path mismatch.

**Fix Strategy**:
```javascript
// âŒ WRONG - Route not registered
// In app.js - missing this line:
// app.use('/api/v1/members', membersRouter);

// âœ… CORRECT - Proper route registration
// File: src/app.js
const express = require('express');
const membersRouter = require('./routes/members');
const subscriptionsRouter = require('./routes/subscriptions');

const app = express();

// Register all routes
app.use('/api/v1/members', membersRouter);  // âœ… Added
app.use('/api/v1/subscriptions', subscriptionsRouter);

// File: src/routes/members.js
const router = express.Router();

// Define routes relative to /api/v1/members
router.get('/', getAllMembers);          // GET /api/v1/members
router.get('/:id', getMemberById);       // GET /api/v1/members/:id
router.post('/', createMember);          // POST /api/v1/members
router.put('/:id', updateMember);        // PUT /api/v1/members/:id
router.delete('/:id', deleteMember);     // DELETE /api/v1/members/:id

module.exports = router;
```

**Test Pattern**:
```javascript
test('GET /api/v1/members should return member list', async () => {
  const { token } = createAuthToken('admin');
  
  const response = await request(app)
    .get('/api/v1/members')
    .set('Authorization', `Bearer ${token}`)
    .expect(200);  // Should NOT be 404
  
  expect(response.body.data).toBeInstanceOf(Array);
});
```

---

#### Issue 4.2: Request Validation Errors

**Symptom**:
```
Error: 400 Bad Request - "full_name_ar is required"
```

**Root Cause**: Missing validation middleware or incorrect validation logic.

**Fix Strategy**:
```javascript
const { body, validationResult } = require('express-validator');

// Validation middleware
const validateMemberCreation = [
  body('full_name_ar')
    .notEmpty().withMessage('Arabic name is required')
    .matches(/[\u0600-\u06FF]/).withMessage('Must contain Arabic characters'),
  
  body('full_name_en')
    .notEmpty().withMessage('English name is required'),
  
  body('national_id')
    .notEmpty().withMessage('National ID is required')
    .matches(/^[12]\d{9}$/).withMessage('Invalid Saudi national ID format'),
  
  body('phone')
    .notEmpty().withMessage('Phone is required')
    .matches(/^(\+966|0)[5]\d{8}$/).withMessage('Invalid phone format'),
  
  body('email')
    .optional()
    .isEmail().withMessage('Invalid email format'),
  
  body('date_of_birth')
    .notEmpty().withMessage('Date of birth is required')
    .isISO8601().withMessage('Invalid date format'),
  
  body('family_branch_id')
    .notEmpty().withMessage('Family branch is required')
    .isUUID().withMessage('Invalid family branch ID')
];

// Apply to route
router.post('/',
  authenticateToken,
  validateMemberCreation,  // âœ… Validation middleware
  async (req, res) => {
    // Check validation results
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    // Proceed with creation
    const member = await createMember(req.body);
    res.status(201).json({ data: member });
  }
);
```

**Test Pattern**:
```javascript
describe('Member Creation Validation', () => {
  test('should reject missing Arabic name', async () => {
    const { token } = createAuthToken('admin');
    
    const response = await request(app)
      .post('/api/v1/members')
      .set('Authorization', `Bearer ${token}`)
      .send({
        full_name_en: 'Mohammed',
        // Missing: full_name_ar
        national_id: '1234567890'
      })
      .expect(400);
    
    expect(response.body.errors).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          msg: 'Arabic name is required'
        })
      ])
    );
  });
  
  test('should accept valid member data', async () => {
    const { token } = createAuthToken('admin');
    
    const response = await request(app)
      .post('/api/v1/members')
      .set('Authorization', `Bearer ${token}`)
      .send({
        full_name_ar: 'Ù…Ø­Ù…Ø¯ Ø§Ù„Ø´Ø¹ÙŠÙ„',
        full_name_en: 'Mohammed',
        national_id: '1234567890',
        phone: '+966550000001',
        date_of_birth: '1990-01-01',
        family_branch_id: testBranch.id
      })
      .expect(201);
    
    expect(response.body.data.id).toBeDefined();
  });
});
```

---

#### Issue 4.3: Response Format Mismatches

**Symptom**:
```
Expected response.body.data, got response.body.result
Expected array, got object
```

**Root Cause**: Inconsistent API response format.

**Fix Strategy**:
```javascript
// âŒ WRONG - Inconsistent response formats
router.get('/members', (req, res) => {
  res.json(members);  // Returns array directly
});

router.get('/subscriptions', (req, res) => {
  res.json({ result: subscriptions });  // Different format
});

// âœ… CORRECT - Standardized response format
const standardResponse = (data, message = null) => {
  return {
    success: true,
    data: data,
    message: message,
    timestamp: new Date().toISOString()
  };
};

const errorResponse = (error, statusCode = 500) => {
  return {
    success: false,
    error: error.message || error,
    statusCode: statusCode,
    timestamp: new Date().toISOString()
  };
};

// Apply consistently
router.get('/members', async (req, res) => {
  try {
    const members = await getAllMembers();
    res.json(standardResponse(members));
  } catch (error) {
    res.status(500).json(errorResponse(error));
  }
});

router.get('/subscriptions', async (req, res) => {
  try {
    const subscriptions = await getAllSubscriptions();
    res.json(standardResponse(subscriptions));
  } catch (error) {
    res.status(500).json(errorResponse(error));
  }
});
```

---

## ðŸ“Š QUICK REFERENCE: COMMON ERROR PATTERNS

```javascript
// Error Pattern â†’ Fix Pattern

// 1. "Cannot read property 'x' of undefined"
// Fix: Add null check
if (!object) return defaultValue;
const value = object?.property || defaultValue;

// 2. "violates foreign key constraint"
// Fix: Create parent record first
const parent = await createParent();
const child = await createChild({ parent_id: parent.id });

// 3. "jwt malformed"
// Fix: Use proper token format
const token = jwt.sign(payload, secret);
headers['Authorization'] = `Bearer ${token}`;

// 4. "Invalid UUID"
// Fix: Use uuid library
const { v4: uuidv4 } = require('uuid');
const id = uuidv4();

// 5. "Arabic text encoding error"
// Fix: Ensure UTF-8
client_encoding=UTF8 in connection

// 6. "null value in column violates not-null constraint"
// Fix: Provide required field
const data = { required_field: value, ...rest };

// 7. "403 Forbidden"
// Fix: Add permission check
app.use('/route', requirePermission('permission_name'), handler);

// 8. "Circular reference"
// Fix: Validate before insert
if (await isCircular(from, to)) throw new Error('Circular');
```

---

**Next Steps**: Proceed to `05_COVERAGE_EXPANSION.md` for guidance on adding new tests.
